{
  "id": "59506",
  "title": "PostScript hinting -- number and weight of standard stems",
  "forum": "Build",
  "tags": [
    "Build"
  ],
  "content": "David Lemon from Adobe writes in his tutorial **_[Basic Type 1 Hinting](http://web.archive.org/web/20120330021131/http:/typophile.com/files/hinting.pdf)_** about the stem weights:\n\n<cite>\"Another font-wide behavior is the stem weights provided for the font. It’s generally best to enter two values for vertical stems and one or two for horizontal, listing the values in ascending order. In a standard Latin font, the values should represent the optimal weight of the normal lowercase and capital stems (hence the two values). These values - especially the first vertical value - are used for a number of rasterization purposes, so it’s important to make them as representative as possible. Two of the most obvious uses include letting ATM know when to turn off synthetic emboldening in a bold design, and serving as target values, to ensure consistent stem weights at low resolutions. In a design where the stems vary slightly in weight, fine-tuning these target values can make a significant difference.\"</cite>\n\nBut that is a try-and-error-solution. I would like to know, how I can find the optimal standard stem values in a more systematic way. And I have recognized, that Adobe (for example) does not use three or four values in all cases. Bold or black fonts, in which the contrast is stronger, seem to need more values. In my opinion the only thing in PostScript hinting, which is hard to do, is finding the optimal standard stems, especially because the output of the autohinting script contained in the **_[Adobe Font Development Kit for OpenType (AFDKO)](http://web.archive.org/web/20120330021131/http:/www.adobe.com/devnet/opentype/afdko/)_** is extremely good. There is another script (setsnap.pl) contained in the AFDKO (coded by **_[Ken Lunde](http://web.archive.org/web/20120330021131/http:/lundestudio.com/)_** in Perl), but the output was not helpful (even not with the non standard options). Unfortunately there is no tutorial, how to make the optimal use of the script (for the case, that it is useful and I am too stupid).\n\n**So my request (because I bang my head against the wall):**  \nPlease teach me! I would like to know a systematic way, how to find the optimal standard stem weights and the optimal number of standard stems. These values are extremely important for PostScript hinting. Even if you do not define individual hints for the glyphs, the values of the standard stems help the rasterizer. (Just make a test: Generate a font file, in which the individual hints are removed only. And generate a second file, in which you additionally have removed the standard stem values. Compare them. If the standard stem values were well chosen, as in Adobe fonts for example, you can see, that the font, in which standard stem values exist, looks much better on screen.)\n\n",
  "author": "Arno Enslin",
  "time": "30 Jun 2009 — 3:08am",
  "uid": "45774",
  "comments": [
    {
      "time": "30 Jun 2009 — 5:23am",
      "content": "I just the Fontlab autohinter and then use the autofill button to have it gather the standard stem values. Then just delete the Fontlab hints.\n\n"
    },
    {
      "time": "30 Jun 2009 — 6:41am",
      "content": "<cite>I just the Fontlab autohinter and then use the autofill button to have it gather the standard stem values. Then just delete the Fontlab hints.</cite>\n\nUp till now I also have used FontLab for computing the standard stems, but that solution is semioptimal. Just open an Adobe original font in FontLab and remove (and forget) the original standard stems. Then try to reproduce the same quality. I would like to know, what exactly I have to measure and why the optimal standard stems are dependent from the number of pixels, in which the font is displayed. The setsnap.pl script indicates, that there are no optimal stems independent from the absolute resolution. But for example, for which size does Adobe optimize the stems and how do they fine tune them? Additionally it does not seem to be needed, that the standard stems match with any real stem width, for example: You have three real horizontal stem widths 10, 18 and 32 units, but your tests show, that you should take one only. So you could sum the three values and devide them by three. The result is 20. Your whole font does not contain a stem with a width of 20, but the rasterizer can make use of the value 20. (This naturally does not mean, that just 20 is the optimal value.) I assume, that FontLab computes standard stems only, that match with real stems. And if not, I would like to know, how FontLab computes the values. By the way the computed values are dependent from the hints, that exist in the font. Change the hints and FontLab computes different standard stems. All this is too arbitrary for being professional. The fact, that there are still so many non Adobe fonts, that are not well hinted, indicates, that there is a need for clarifying the problem. PostScript hinting is not magic. I keep my hands from TrueType hinting, but I really want to understand, how exactly PostScript hinting works. David Lemon’s tutorial is cool and his writing style eases the understanding, but it is not enough. I need more info. The individual hints are not the problems, but the standard stems are a big one in my opinion. (I also have a need for clarifying the exact influence of the BlueShift and the BlueScale value. I got info about the meaning from the Type1 blackbook, but the info is too compressed and partly too cryptical.)\n\n"
    },
    {
      "time": "1 Jul 2009 — 6:39am",
      "content": "Arno,\n\nThe setsnap.pl Perl script was originally a C program that I wrote in the early 1990s. I ported it to Perl three or four years ago.\n\nLike you, I do not run this script directly, but instead have a batch file, which happens to be another Perl script, that invokes it with specific options.\n\nThe default behavior of setsnap.pl is to simply indicate the highest-frequency stem widths. It is expected to use the output of another AFDKO tool, specifically stemHist, as its input. The stemHist tool outputs two files, one for horizontal stems, and another for vertical ones.\n\nI have found that selecting appropriate stem values is a combination of art, science, and philosophy. The easiest and fastest approach is to simply take the highest-frequency stem values, for horizontal and vertical. For many purposes, this will provide adequate results. Our rendering experts have always claimed that having no hints is better than having poor hints. Selecting the highest-frequency stems could never be construed as having poor hints.\n\nOne point of more careful selection of stem values involves a range within which the stems result in the same relative rendered size. The parameters are resolution and point size. If you set these (the setsnap.pl tool has options for these, but also has defaults if they are not set, specifically 72-dpi for the resolution, and 9- through 24-point as the point size range), you can experiment with various values.\n\nIn the past, like nearly twenty years ago, we set the hinting parameters for our Japanese fonts by looking at only one or two rowfonts for each hint dictionary. For the kanji, this meant using only a small fraction of the glyphs to determine these values. When I originally wrote setsnap.pl in C, which was simply called setsnap, one purpose was to be able to use all of the rowfonts to calculate the stem values. (The purpose of setsnap.pl's \"-s\" option, which was also a feature of the original C version, is to additionally output a new stemHist file, and it assumes that its input is a bunch of them that have been concatenated from multiple rowfonts.) This resulted in much more accurate stem values, even if the highest-frequency one is to be selected.\n\nIf you select only one stem value for horizontal and vertical, these become the StdHW and StdVW values of the font dictionary, respectively. You can also set the StemSnapH and StemSnapV arrays, meaning that multiple values are specified. Whether multiple values need to be specified depends on the font data. My \"rule of thumb\" is to keep multiple StemSnapH and StemSnapV values at least 10 units apart. And, as you are no doubt aware, one of the StemSnapH and StemSnapV values must be the same as set for the StdHW and StdVW values, respectively. If the output of the setsnap.pl tool suggests that there are two or three high-frequency stems that are at least 10 units apart, it would be a good idea to specify these in the StemSnapH and StemSnapV arrays, being sure to include the highest-frequency one as the StdHW and StdVW values. (The setsnap.pl tool outputs the highest-frequency stem, so you need to look into the output of stemHist to find others.)\n\nAs an example, here is the horizontal stemHist output for the \"Kanji\" hint dictionary of RyoDispPlusN-Heavy (created by using the setsnap.pl \"-s\" option to concatenate multiple stemHist output files):\n\nCount Width  \n536 7  \n254 8  \n262 9  \n266 10  \n879 11  \n1623 12  \n1033 13  \n279 14  \n167 15  \n35275 16  \n576 17  \n559 18  \n264 19  \n207 20  \n212 21  \n218 22  \n229 23  \n414 24  \n346 25  \n383 26  \n522 27  \n626 28  \n429 29  \n615 30  \n858 31  \n774 32  \n393 33  \n1031 34  \n201 35  \n121 36  \n43 37  \n20 38  \n47 39  \n22 40  \n72 41  \n18 42  \n12 43  \n24 44  \n17 45  \n15 46  \n26 47  \n8 48  \n11 49  \n223 50  \n9 51  \n6 52  \n12 53  \n20 54  \n10 55  \n2 56  \n16 57  \n14 58  \n8 59  \n67 60  \n15 61  \n15 62  \n4 63  \n4 64  \n2 65  \n10 66  \n6 67  \n7 68  \n4 69  \n9 70  \n12 71  \n8 72  \n8 73  \n10 74  \n15 75  \n8 76  \n17 77  \n14 78  \n15 79  \n13 80  \n14 81  \n18 82  \n10 83  \n13 84  \n21 85  \n12 86  \n20 87  \n20 88  \n24 89  \n22 90  \n19 91  \n29 92  \n41 93  \n55 94  \n22 95  \n25 96  \n33 97  \n22 98  \n35 99  \n29 100  \n32 101  \n27 102  \n35 103  \n43 104  \n50 105  \n40 106  \n67 107  \n68 108  \n51 109  \n43 110  \n61 111  \n64 112  \n45 113  \n46 114  \n40 115  \n63 116  \n69 117  \n59 118  \n40 119  \n60 120  \n52 121  \n42 122  \n84 123  \n60 124  \n67 125  \n52 126  \n45 127  \n77 128  \n158 129  \n48 130  \n99 131  \n53 132  \n24 133  \n60 134  \n29 135  \n40 136  \n37 137  \n37 138  \n15 139  \n43 140  \n35 141  \n36 142  \n51 143  \n57 144  \n43 145  \n42 146  \n18 147  \n36 148  \n35 149  \n26 150  \n17 151  \n32 152  \n35 153  \n31 154  \n27 155  \n13 156  \n34 157  \n19 158  \n28 159  \n24 160  \n14 161  \n19 162  \n12 163  \n53 164  \n11 165  \n44 166  \n22 167  \n10 168  \n41 169  \n12 170  \n6 171  \n6 172  \n66 173  \n7 174  \n10 175  \n7 176  \n4 177  \n8 178  \n3 179  \n2 180  \n47 181  \n4 182  \n6 183  \n2 184  \n1 185  \n3 187  \n2 188  \n2 189  \n3 190  \n1 191  \n4 192  \n1 193  \n3 195  \n2 196  \n1 199  \n1 200  \n1 201  \n1 202  \n1 206  \n1 213  \n1 222\n\nIt is little wonder that setsnap.pl indicates that \"16\" is the highest-frequency horizontal stem value, with 35,275 hits. (Keep in mind that the \"Kanji\" hint dictionary of this font includes glyphs for approximately 8,000 kanji.) In fact, the stem value of 16 is such a high frequency that we set only StdHW for this font, specifically a value of 16, and do not include a StemSnapH array. If I were to set a StemSnapH array, the stem value of 34 would be a likely candidate to include in it.\n\nHopefully this helps to some degree...\n\nDr. Ken Lunde  \nSenior Computer Scientist, CJKV Type Development  \nAdobe Systems Incorporated  \n [lunde@adobe.com](mailto:lunde@adobe.com)\n\n"
    },
    {
      "time": "1 Jul 2009 — 8:44am",
      "content": "Thanks, Ken! I try again to comprehend and reproduce the standard stems of some Adobe fonts.\n\n"
    },
    {
      "time": "1 Jul 2009 — 9:00am",
      "content": "You are overthinking this :)\n\n"
    },
    {
      "time": "1 Jul 2009 — 9:15am",
      "content": "Arno,\n\nYour goal should not be to reproduce the standard stems of some of our fonts, because there are no \"correct\" values. Rather, think of this exercise in terms of choosing one of many possible \"correct\" or \"appropriate\" values.\n\nScience is used to reveal candidate stem values, either through simplistic calculations (highest-frequency, for example), or more complex ones (as the \"-o\" option of setsnap.pl uses, which takes resolution and point size ranges into account).\n\nPhilosophy is then used to pick from among the candidate values, and a good rule is that if you cannot decide between two relatively close values, choose the lower of the two.\n\nArt even comes into play. Experience is also another factor.\n\nI also agree that you should not overthink this.\n\nIf you'd like me to take a stab at a font, feel free to send to me the stemHist output files, and I'll let you know what I think are appropriate stem values.\n\nDr. Ken Lunde  \nSenior Computer Scientist, CJKV Type Development  \nAdobe Systems Incorporated  \n [lunde@adobe.com](mailto:lunde@adobe.com)\n\n"
    },
    {
      "time": "1 Jul 2009 — 10:09am",
      "content": "_Bold or black fonts, in which the contrast is stronger, seem to need more values._\n\nI don't think it's the contrast. There are often more quite distinct (numerically far apart) stem widths in the heavier weights.  \nThat's because with reference to the desirability of an overall even quality in text, \"colour\" (or notan) is more apparent and more instrumental in bold weights than the thickness of stems.  \nFor instance, Futura:\n\n ![](http://web.archive.org/web/20120330021131im_/http:/typophile.com/files/FutET_5116.jpg)\n\n"
    },
    {
      "time": "1 Jul 2009 — 10:18am",
      "content": "H  \nH  \nH  \nH\n\nChrisL\n\n"
    },
    {
      "time": "1 Jul 2009 — 12:25pm",
      "content": "<cite>If you’d like me to take a stab at a font, feel free to send to me the stemHist output files, and I’ll let you know what I think are appropriate stem values.</cite>\n\nThanks, Ken. I would also send you a list of standard stems, from which I think, that they are well chosen.\n\nBut another question: Imagine, that you have a font with the following real stem widths. (The font does not have any curves.)\n\nVERTICAL STEMS: 30 and 60  \nHORIZONTAL STEMS: 40 and 50\n\nThen I would set the following vertical standard stems:  \n30 and 60\n\nBut I would think about deviding the sum of 40 and 50 for the one and only value of the horizontal standard stems, because the rasterizer tries to render in the width of the standard stems independent from the question, if their widths match with real stems. Would this be wrong? More to the point, there is no duty to choose standard stems, that really exist in the font, isn’t it? If, for example, the regular style and the italic style of a font are very similar in weight, I could use the same standard stems for both styles.\n\nAnd another thing with regard to bold and black styles: In my opinion it sometimes is better, not to provide any hints for those bold and black styles, but standard stems only. This often looks more smooth. Or alternatively vertical and horizontal standard stems, but vertical hints only. (Vertical hints hint horizontal stems.) Or as very elegant alternate way, vertical and horizontal standard stems and vertical ghost hints, that are exactly on the top and under the bottom of each glyph. I don’t know, whether that works, but I had this idea, when I saw the bar of a small t, which should align with the other small letters. I could not extend the alignment zone down to the top of the bar of the t, because there seems to be a maximum allowed width of alignment zones, but I have successfully aligned the bar of the t with the help of a ghost hint. (When I tried to extend the alignment zone down to the bar of the t, the alignment of all the other small letters did not work anymore.) And, surprise, if the ghost hint overlaps with the bar of the t and with the alignment zone, it will be additionally hinted.\n\nYes, it may be, that I overthink this, but it really is hard to get detailed information about hinting without asking experts. The only tutorial with regard to PostScript-hinting seems to be David’s.\n\n----------\n\nKen, I already have posted a bug report on the FontLab forum about the autohinting macro of the latest AFDKO. (The option \"suppress hint substitution\" does not work for sure and the option \"allow changes in outlines\" doesn’t seem to work.) But maybe it is better to contact the developers directly. Is there a better place, on which I can report bugs?\n\n"
    },
    {
      "time": "1 Jul 2009 — 1:44pm",
      "content": "[My bug report of the autohinting macro, that is contained in the AFDKO.](http://web.archive.org/web/20120330021131/http:/forum.fontlab.com/adobe-fdk-for-opentype-afdko/bug-in-autohintscript-belonging-to-the-afdko-25-21898-t7057.0.html;msg23917#msg23917)  \nI have fixed the bug and attached it there.\n\nI can edit my first message only. Why not the last one? That’s odd.\n\n"
    },
    {
      "time": "1 Jul 2009 — 4:00pm",
      "content": "Quoting myself  \n<cite>(Vertical hints hint horizontal stems.)</cite>\n\nThis is a point, in which I am not sure. In Fontographer hints of horizontal stems are displayed as vertical arrows. In FontLab they are displayed as two dashed horizontal lines. And in the FontLab terminology a vertical hint hints a vertical stem. On the one side the FontLab terminology is more intuitive. On the other side it is contradictory regarding to the alignment function of hints. And it ignores the difference between a normal and a ghost hint. So I prefer **ed** to call a hint, that hints a vertical stem, a horizontal hint. But I am relatively sure, that it is defined in a specification. I only have to find it.\n\nEdited:\n\nFrom the Type1 blackbook:\n\n<cite>The vstem hint, for each vertical stem (such as the legs of the<br>\nletter “n” or the leftmost and rightmost sections of the letter “o”)<br>\ntakes two x values (expressed as x and delta-x) as arguments. These<br>\ntwo x values indicate the horizontal range that the vertical stem’s<br>\nwidth occupies in character space.</cite>\n\nI change my opinion and call vstem hints vertical hints in future. Or vstem hints.\n\n"
    },
    {
      "time": "10 Jul 2009 — 7:35pm",
      "content": "Sorry the hinting documentation is so limited. The tutorial I wrote so long ago was focused on Fontographer, and omitted things that FOG can't do. We are (more accurately: Miguel is) working on an expanded version, but it's a slow project and likely to take quite a while longer.\n\nArno asked:  \n<cite>But I would think about dividing the sum of 40 and 50 for the one and only value of the horizontal standard stems, because the rasterizer tries to render in the width of the standard stems independent from the question, if their widths match with real stems. Would this be wrong? More to the point, there is no duty to choose standard stems, that really exist in the font, isn’t it?</cite>\n\nThere's no requirement that the standard stem weights match actual stems. Often the best result is more of an average of several closely-related values. But it does need to really represent the weight of the design.\n\n<cite>If, for example, the regular style and the italic style of a font are very similar in weight, I could use the same standard stems for both styles.</cite>\n\nThis would be a bad idea. The rasterizer tries to make a visible difference between the regular and bold weights at small sizes (where both may have one-pixel stems), and uses the stem weight values to figure out what weights it's dealing with. If you lie to the rasterizer you're not likely to get good results.\n\n"
    },
    {
      "time": "9 Mar 2010 — 11:42am",
      "content": "@ David or Miguel\n\nIs the expanded version already available? I even would be interested in it, if it is in a beta stadium.\n\n"
    }
  ]
}
