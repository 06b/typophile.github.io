{
  "id": "18814",
  "title": "Calling all Hinting Programming Gurus",
  "forum": "Build",
  "tags": [

  ],
  "content": "What would it take to write a utility (or possibly Python code)  \nthat takes two outline-compatible TT fonts, let’s call them Main  \nand Alternate, and creates one TT font that’s essentially Main  \nbut with hinting to make it be Alternate at a given PPEM?\n\nhhp\n\n [‹ PDF open in full screen mode](http://web.archive.org/web/20080503010639/http:/typophile.com/node/18384 \"Go to previous forum topic\") [Is the Term “Pro” Adobe property or a defacto standard? ›](http://web.archive.org/web/20080503010639/http:/typophile.com/node/19012 \"Go to next forum topic\")\n\n",
  "author": "<a href=\"/web/20080503010639/http://typophile.com/user/1250\" title=\"View user profile.\">hrant</a>",
  "time": "<br>",
  "uid": "1250",
  "comments": [
    {
      "time": " 26.Mar.2006 7.03am",
      "content": "So what you want is a set of hints that distort the normal outlines to match the bitmaps that result from the outlines of the Alternate outlines at a given size?\n\n"
    },
    {
      "time": " 26.Mar.2006 7.19am",
      "content": "That would just be superhinting. What I’d like:  \n1) Does the hinting for you.  \n2) Works from outline fonts, without “external” references like bitmaps.  \n3) Most of all: isn’t limited to screen rendering needs...\n\n—\n\nBTW, I should have said “at a given PPEM range”.\n\nhhp\n\n"
    },
    {
      "time": " 26.Mar.2006 1.40pm",
      "content": "I’d like to see code that will design a typeface for me!\n\n"
    },
    {
      "time": " 26.Mar.2006 1.45pm",
      "content": "This isn’t nearly that bad. The code doesn’t have to be smart - not at all. All it has to do is deploy hinting that makes the points of the Main font become the points of the Alternate when the PPEM is within a certain range (including a single PPEM\\* in the case of bitmap rendering).\n\n\\* Or actually, a set of single PPEMs, to get multiple bitmaps in one outline font.\n\nhhp\n\n"
    },
    {
      "time": " 26.Mar.2006 2.55pm",
      "content": "What kind of hinting are we talking about?\n\n"
    },
    {
      "time": " 26.Mar.2006 3.05pm",
      "content": "The kind that moves points around?\n\nhhp\n\n"
    },
    {
      "time": " 26.Mar.2006 3.28pm",
      "content": "Ah, so you’re not talking about hinting in the traditional sense. You simply want outline substitution?\n\n"
    },
    {
      "time": " 26.Mar.2006 5.59pm",
      "content": "Yes, I did understand your desired process correctly. I just wanted to be sure what the result was supposed to be.\n\nThe short answer is no, I don’t think there is a way to do this.\n\nThe results of gridfitting are size-specific, so at best you would get an outline correspondence at one size only. Delta hints are expressed, obviously, as deltas to the unadjusted position, not as target point positions. You are saying ’Move this point a distance from its current position’, not ’Move this point to this location’, and since the delta technology was designed to turn whole pixels on or off the units are quite crude. Even if you knew exactly what the target position was, in xy coordinates from your alternate outline, the chance of being able to hit it precisely with hinting is very remote, unless that alternate outline had been designed very precisely for a particular ppem size.\n\nI think Sergej is right, and what you are looking for is outline substitution. No idea if that is possible.\n\n"
    },
    {
      "time": " 26.Mar.2006 7.56pm",
      "content": "\\> Delta hints are expressed, obviously, as deltas to  \n\\> the unadjusted position, not as target point positions.\n\nSure. But how does this make it impossible?  \nYou measure the difference between the points,  \nand you move the Main points by that amount.\n\nAlso: Deltas are applied per PPEM, right? So, just like you  \ndo in 1-bit, you have sets of deltas that make a glyph come  \nout right for each point size.\n\n\\> unless that alternate outline had been  \n\\> designed very precisely for a particular ppem size.\n\nIt has.  \nIt’s designed to 1/4 pixels in each dimension.\n\n\\> since the delta technology was designed to turn whole pixels on or off\n\nBut I was pretty sure that it was ammended to address partial pixels, no?\n\n—\n\nWhat I’m describing can be done manually, I’m pretty sure.  \nThe question is, how hard would it be to automate it based  \non a explicit outline pair? In the worst case, a low-level  \nutility would have to be written to do with the TT code as  \nit pleases (which would be too much work, unless somebody  \nwere to process truck-loads of such fonts). In the best case, I  \nsuspect Python could be made to splice in the needed hints, no?\n\nhhp\n\n"
    },
    {
      "time": " 27.Mar.2006 5.30am",
      "content": "you can’t mix tt code and composite code unfortunately so you can’t use say an if statement and select one glyph or another.\n\nsort of like that. But VTT does not allow it since composite commands for glyphs are different than normal tt instructions. You can use some tt code in composites. But you can’t mix the 2 apparently like below.\n\nUSEMYMETRICS[]  \nOVERLAP[]  \nOFFSET[R],35,0,0  \n#PUSHOFF  \n#PUSH, 28  \nMPPEM[]  \nIF[]  \nOVERLAP[]  \nOFFSET[R],380,319,0  \nELSE[]  \nOVERLAP[]  \nOFFSET[R],381,319,0  \nEIF[]\n\n"
    },
    {
      "time": " 27.Mar.2006 6.27am",
      "content": "I think you’ve overshot my grasp of all this. Patience, please! :-)  \nI’d rather not get into outline subbing though.\n\nOK, let me ask this:  \n1) Can’t you use something like VTT to take the Main font, choose a PPEM, and manually move the points so you get the points of the Alternate?  \n2) Can’t this difference information be extracted from comparing the two outlines?\n\nIf the answer to both those is Yes, shouldn’t it be possible to write some code that takes the Main font, observes its differences with the Alternate font, is given a PPEM, and with all that info generates a font like I’m saying?\n\nhhp\n\n"
    },
    {
      "time": " 27.Mar.2006 7.21am",
      "content": "MPPEM[] returns the PPEM  \nthe instruction for PointSize doesn’t work and is useless since size is dependant on resolution.\n\nSo yes you can check what PPEM you are at and do something. I wrote a function that flattens flairs on a contour until a specified distance is reached (in 64ths of a pixel). Usually sometihng like 2 pixels.\n\n/\\* Function 81 TAKES 3 ARGUMENTS, aligns a point until a specific distance is reached.Used for flares. First link p1 to p2, then call the function. VC Dec 11,1995\\*/  \n/\\* CALL[], amt, p1, p2, 81 ... amt is in 64ths, p1 is start pt, p2 is point moved, 81 is function# \\*/  \nFDEF[], 81  \n#BEGIN  \n#PUSHOFF  \nDUP[]  \nROLL[]  \nSWAP[]  \nMD[N]  \nABS[]  \nROLL[]  \nSWAP[]  \nGTEQ[]  \nIF[]  \nALIGNRP[]  \nELSE[]  \nPOP[]  \nEIF[]  \n#END  \n#PUSHON  \nENDF[]\n\npoint related instructions are here:  \n [http://www.microsoft.com/typography/tt/ttf\\_spec/ttch06b.doc](http://web.archive.org/web/20080503010639/http:/www.microsoft.com/typography/tt/ttf_spec/ttch06b.doc \"http://www.microsoft.com/typography/tt/ttf\\_spec/ttch06b.doc\")\n\nAlso the instruction I was thinking of before was ’FLIPPT[]’ Flip point which will make an on curve point an off curve point and the other way around. That way you don’t have curves just straight lines everywhere, easier to put on grid boundries.\n\nThe TrueType instruction set was not designed to do what you are asking. But you can, at a certain PPEM use one CVT (control value) for small sizes (using MIAP and setting it to not look at the cut-in limit), an X height for instance, and then use a smaller one for larger print sizes. You could also move points or use larger CVT values to thicken up the stems at smaller sizes.\n\nBut using instructions in a heavy handed way is always dangerous since they might not get used by some devices. (like some printers)\n\nTrueType has the ability to manipulate outlines using a matrix but its implementation doesn’t always support this. Ie. Hp Deskjets back in the early 1990’s couldn’t handle flipped glyphs or scaled glyphs. In theory the SOFFSET let’s you skew, scale, or flip. FontLab will output a composite in TTF using the SOFFSET if you flip or scale it.\n\n"
    },
    {
      "time": " 27.Mar.2006 8.13am",
      "content": "fun flipping fun...\n\nFLIPRGON[],0,42  \nturns all the points into on curve points ’vectorizing’ the outline. (the mid 1980’s digital typesetters used straight line vectors to create curves, Ikarus followed making curvilinear outlines)\n\n ![](http://web.archive.org/web/20080503010639im_/http:/typophile.com/files/flip.jpg)\n\n"
    },
    {
      "time": " 27.Mar.2006 8.56am",
      "content": " ![](http://web.archive.org/web/20080503010639im_/http:/typophile.com/files/o_if.jpg)\n  \nthe left images is 24 PPEM, it uses a CVT that is 2 times (418 UnitsPerEM) that of the outline distance (209 UPEM). the right is 25PPEM it uses the actual value  \n`\n/* previously the glyph is hinted as normal then this */\n<\\code>\n#PUSHOFF /* set instructions to manual mode */\nMPPEM[] /* get the ppem size */\n#PUSH, 24 /* this is the size I want to change */\nEQ[] /* are they equal ? */\nIF[] /* if true do this */\n#PUSHON /* set instructions to automatic mode */\n#BEGIN /* begin block */\nSVTCA[X] /* set direction to X */\nSRP0[], 5 /* start link at pt 5 */\nMIRP[m>RBl], 36, 192 /* link pt 5 to pt 36 using cvt 192 */\nSRP0[], 14 /* start a link from pt 14 */\nMIRP[m>RBl], 26, 192 /* link from 14 to 26, using cvt 192 */\nIUP[X] /* interpolate all the other points in X */\n#END\nEIF[]\n<\\code>\n`\n"
    },
    {
      "time": " 27.Mar.2006 9.08am",
      "content": "the only problem with doing this kind of thing is that the screen size will not represent the printer output. You could use embedding bitmaps to solve that at the main sizes. if you really wanted to.\n\nDoes that prove you can manipulate the glyph at certain sizes for you ?\n\n"
    },
    {
      "time": " 28.Mar.2006 11.12am",
      "content": "Vincent, thanks for all this. DM is lucky to have you.\n\nFirst, some asides:\n\n\\> the instruction for PointSize doesn’t work and  \n\\> is useless since size is dependant on resolution.\n\nUnless there’s a way for the font to find  \nout the OS’s nominal resolution setting...  \nIs there?\n\nSpeaking of fonts detecting things: did I read you mention  \nthat there’s a way for a font to check if CT is on or not?\n\n\\> in 64ths of a pixel\n\nBTW, why such a fine scale? I thought Windows (for one) uses  \nonly 16 shades of gray when rendering gs fonts, which would  \nmean 1/4 pixels (in each dimension) should be enough, no?\n\n—\n\n\\> FLIPPT[] ... straight lines everywhere\n\nUseful!  \nBTW, you could nick-name that process “Downerize”. :-)\n\n\\> thicken up the stems at smaller sizes.\n\nHeh, heh - you’re reading my mind concering my #3 above...\n\n\\> using instructions in a heavy handed way is always  \n\\> dangerous since they might not get used by some devices.\n\nBut if they’re ignored, what’s the worst that can happen?  \nWon’t you just get what you were going to anyway, like in  \nthe case of bitmap tuning you’d revert to the fuzzy stuff.\n\nOr are you saying that some instructions wouldn’t  \nwork but some would so you’d get a hodge-podge?\n\n\\> it uses a CVT that is 2 times (418 UnitsPerEM) that of the outline distance\n\nYou’re talking about the CVT that controls curve widths I see.\n\nSo it’s all looking possible, eh?\n\nNow, what would it take to automate this, and tweak the CVTs using data  \nfrom the differences between two (outline-compatible) outline fonts?\n\n\\> You could use embedding bitmaps\n\nI’m actually a big fan of embedded bitmaps, and have a few fonts that way, like Arasan\\*. But besides the fact that they don’t work on MacOS\\*\\*, the critical thing is that they don’t handle grayscale bitmaps. Or actually, I’ve been told they do, but after trying for a while I had to give up. In my best effort I did get grays, but they were totally off in value. On the other hand, I was using a beta of BitFonter, and maybe the later versions made some fix? I asked the Pyrus boys about this a few times a while back, but never got a convincing reply (which is pretty rare for them).\n\n\\* [http://www.themicrofoundry.com/f\\_arasan.html](http://web.archive.org/web/20080503010639/http:/www.themicrofoundry.com/f_arasan.html \"http://www.themicrofoundry.com/f\\_arasan.html\")\n\n\\*\\* Not that hints work these days either I guess... :-/\n\nhhp\n\n"
    },
    {
      "time": " 28.Mar.2006 3.09pm",
      "content": "\\>Speaking of fonts detecting things: did I read you mention  \n\\>that there’s a way for a font to check if CT is on or not?\n\nYou can use VTT functions that were used for grey or binary to do CT delta like hinting. But you have to add to one of the functions and know the settings and add to the function.\n\nCVTs are control values. You use them for heights or stem widths. So you could in theory thicken up all the stems at small sizes for small text use and increase the xheight but then use others for normal text sizes.\n\n\\>64ths  \nthe Truetype spec measures distances in 64ths of a pixel.\n\n\\>Or are you saying that some instructions wouldn’t  \n\\>work but some would so you’d get a hodge-podge?\n\nnone would work or all would. example: Bitstream’s Font Fusion has modes so it sometimes might not use the hints. It depends how it’s set up.  \n [http://www.bitstream.com/font\\_rendering/products/font\\_fusion/ffoverview....](http://web.archive.org/web/20080503010639/http:/www.bitstream.com/font_rendering/products/font_fusion/ffoverview.html \"http://www.bitstream.com/font\\_rendering/products/font\\_fusion/ffoverview.html\")\n\nYou can’t read between fonts. The code in the font is internal. What you want to do is outside of the scope of a font file. It’s part of the rasterizer or a state engine.\n\nQuickDraw GX supported morphing images. In 1992 at the Apple Safari Erik and Just showed Trixie being tweeked to be lighter or darker depending if the ribbon was new or old.\n\nI morped a symbol USA font to change into fire krackers. This was done by QuickDraw GX and very useless.\n\nOpenType was to solve more serious problems such as ones in languages. It was decided that solving Asian font issues, for instance was more important than if you could make an ’A’ thicker.\n\n"
    },
    {
      "time": " 29.Mar.2006 9.57pm",
      "content": "\\> you could in theory thicken up all the stems  \n\\> at small sizes for small text use and ...\n\nCool. Here’s a cruncher:  \n<cite>Could you also vary set-widths?</cite>\n\nAnd if so, what would the consequences be for line-break flows,  \ncorrespondences between screen and print, and who knows what else?\n\n<cite>What kind of stuff would hit the fan if a<br>\nfont were hinted to set to a different<br>\nwidth at certain PPEMs?</cite>\n\n\\> What you want to do is outside of the scope of a font file.\n\nSure. In fact I’d be shocked if a font could like contain  \ntwo fonts, take measurements between them, adjust itself, etc.\n\nLike I said at the very beginning, what I’d like is an external  \napp/utility, but maybe hopefully just Python code, that creates  \na new font with its “custom” hinting, based on the input of a  \ngeneral font and a PPEM-specific font (the two outline-compatible).\n\nSo if you think it’s doable, what would it take, effort-wise?\n\nhhp\n\n"
    },
    {
      "time": " 30.Mar.2006 12.16am",
      "content": "\\>And if so, what would the consequences be for line-break flows,  \n\\>correspondences between screen and print, and who knows what else?\n\nnon linear hinting of widths has been a part of TrueType since the beginning. Bitmaps are often on larger widths at small sizes than they would be if it’s width value was calculated for that size linearly.\n\nwhen we made Tahoma I had to support Matthew Carter and Tom Rickner by giving them (or Matthew) the escapements for some of the core bitmap fonts that were part of Windows, (I made most of the original bitmaps for Tahoma for Windows). The old system bitmap fonts (like all) do not scale linearly ie. the ’space’ might be 3 pixels at 9ppem, 4 pixels at 10ppem, then 3 at 11ppem. Often the ’l’ or ’i’ needs to be more than 1 pixel wide or it crashes with other characters and doesn’t centre so you make it’s width one bigger.\n\nthe ’hdmx’ is there to speed up line layout. Also there is always some give and take in page layout the screen is just a representation of the printed page and simulates a point size.\n\n"
    },
    {
      "time": " 30.Mar.2006 1.05am",
      "content": "Sure\\*, but you’re talking about one pixel here, offset by one pixel there, with the overall average about the same.\\*\\* I’m talking about all the glyphs rendering out 1, 2, or more pixels wider (for smaller sizes) onscreen than their print “originals”.\n\n\\* Although “non-linear” isn’t the term I’d use.\n\n\\*\\* With each app apparently choosing whether to use the integer (hinted) bitmap widths to set a line (like WordPad) or the -cumulative- actual (non-hinted) outline widths (like Word); the latter to ensure linebreak (and justification) consistency with print, but causing the occasional bad spacing (including collisions).\n\n\\> I made most of the original bitmaps for Tahoma for Windows\n\nWait a second. And Tahoma came before Verdana (plus their blackbody bitmaps are identical anyway). So you’re saying all this time we’ve been told incorrectly that Carter made the bitmaps (or am I remembering wrong).\n\nhhp\n\n"
    },
    {
      "time": " 30.Mar.2006 4.06am",
      "content": "Hrant, is looking for the resolution axis of a Variation font. No doubt about it.\n\n"
    },
    {
      "time": " 30.Mar.2006 6.08am",
      "content": "Ideally, yes. Maybe call it a Fidelity axis. With one extreme being  \nwhere a person runs off with the best\\_man/matron\\_of\\_honor, and  \nthe other this: [http://news.bbc.co.uk/2/hi/europe/4198155.stm](http://web.archive.org/web/20080503010639/http:/news.bbc.co.uk/2/hi/europe/4198155.stm \"http://news.bbc.co.uk/2/hi/europe/4198155.stm\")\n\nAnyway, I’d actually just be happy to get things like:  \n1) Traps popping in/out depending on point size.  \n2) Let’s say three gs bitmap sizes “embedded”.  \nAnd I’d be ecstatic to get optical scaling in there.  \nImagine, a fool-proof way to get large type to look  \nelegant and small to be readable <cite>in spite</cite> of the setter.  \nImagine aaaaall the people, living... Wait, that’s another thread.\n\nhhp\n\n"
    },
    {
      "time": " 30.Mar.2006 7.38am",
      "content": "\\>Wait a second. And Tahoma came before Verdana (plus their blackbody \\>bitmaps are identical anyway). So you’re saying all this time we’ve \\>been told incorrectly that Carter made the bitmaps (or am I \\>remembering wrong).\n\nTahoma was the regular weight font and was made first, Verdana was the bold. Verdana was originally called Ohana but that got dropped.\n\nWe were trying to replace MS Sans as the UI font in Windows 95 to make it look very different than anything out there (at the last minute!). Changing the UI font was the quickest way to do that.\n\nWe had to come as close as possible to MS Sans bitmaps that were in Windows. So somebody has to open up all those bitmaps and come up with numbers and in some cases convert the bitmap fonts so Matthew could use them on his Mac and that was me.\n\nMatthew made the bitmaps and in some cases used negative sidebearings (the bitmap went out of the width). Matthew designs on a Mac.\n\nI had to correct the bitmaps and remake them in the Window SDK tool for making fnt’s and then we used those in test Versions of Windows 95. The fnt bitmap format didn’t support negative lsb or rsb.\n\nWe went through many versions and many system tests (many) and eventually it was not accepted because it was not exactly the same as Ms Sans for the escapements. This would cause massive problems for thousands of applications developers developing for Windows. It also was different than what most people were use to seeing so they thought MS Sans was better (mostly because of the ’what you read most, reads best theory’).\n\nMatthew made the first bitmaps, I made them work.\n\nEventually I had to calculate the metrics from the bitmaps for the TrueType font then when Matthew made the outline I embedded the bitmaps into the fonts so Tom Rickner could use them to hint the font to get the exact image as the bitmaps.\n\nThere were many people involved in the making of Tahoma, we are generally credited in talks about Tahoma as ’the engineers’. We ’the engineers’ were trying to maintain backward compatibility and do something different, not just do something different.\n\nEventually Tahoma got picked up by Office for its dialogs after Internet Explorer shipped with the bolder font Verdana.\n\nI made Trebuchet after/during the hinting of Tahoma. The way the shapes came out largely is caused by making sure at the small sizes the bitmaps were all different than Tahoma. I made the ’M’ angled because Tahoma was straight. I used a serif on the ’l’ because Tahoma didn’t and made the ’g’ 2-story since his was one story. I also made my cap height, x-height and ascenders different. At 10 or 11 ppem there is very little difference between one font and another other than the white space and the Cap height. Matthew made his ascenders bigger than his Caps to separate them visually, and made a big x-height.\n\n"
    },
    {
      "time": " 30.Mar.2006 10.09am",
      "content": "Thanks for the history.\n\n\\> Ohana\n\nThat’s keeper trivia right there.  \nI guess they dumped it because of the potential confusion  \nin Hawaii: “No, NO, Ohana is <cite>one of the fonts</cite> in the family!” ;-)\n\n\\> Matthew made the first bitmaps, I made them work.\n\nGot it.\n\n\\> I embedded the bitmaps into the fonts\n\nI’m really curious, assuming you can remember/dig\\_it\\_up (I hope so)  \nwhat the comparative filesize was between your transitional font and  \nthe final superhinted version. I ask because one classic argument in  \nsupport of superhinting versus embedded bitmaps (at least before CT :-)  \nwas filesize. The thing is, the hints in the old MS core fonts took up  \nfully HALF the file size!! So I’m suspicious. Hopefully we can unravel  \nthis once and for all.\n\n\\> the bolder font Verdana\n\nI didn’t say anything the first time :-) but are you sure you mean bolder? I mean, Verdana has 1- and 2-pixel stem Regular and Bold fonts just like Tahoma (and I think they “break” at the same PPEMs). In fact, if anything, Verdana’s looser spacing (its [official] raison-d’être vis-a-vis Tahoma) makes it slightly lighter.\n\n\\> Trebuchet... making sure at the small sizes  \n\\> the bitmaps were all different than Tahoma.\n\nI think I’d read that before (but is less detail).  \nIt’s an interesting, and to me not invalid, strategy.\n\nhhp\n\n"
    },
    {
      "time": " 30.Mar.2006 10.23am",
      "content": "BTW:  \n\\> [http://www.bitstream.com/font\\_rendering/products/font\\_fusion/ffoverview....](http://web.archive.org/web/20080503010639/http:/www.bitstream.com/font_rendering/products/font_fusion/ffoverview.html \"http://www.bitstream.com/font\\_rendering/products/font\\_fusion/ffoverview.html\")\n\nMan, I <cite>never</cite> get tired of doing this: :-)\n\nVersus Mana-11 Bold:\n\n ![](http://web.archive.org/web/20080503010639im_/http:/typophile.com/files/Mana11BvsFusion.gif)\n  \n\\_\n\nVersus Mana-13 Bold:\n\n ![](http://web.archive.org/web/20080503010639im_/http:/typophile.com/files/Mana13BvsFusion.gif)\n  \n\\_\n\nVersus Mana-16 Regular:\n\n ![](http://web.archive.org/web/20080503010639im_/http:/typophile.com/files/Mana16RvsFusion.gif)\n  \n\\_\n\nFontFusion: Nice algorithm, like most other  \nthings Bitstream does. But not good enough.\n\nhhp\n\n"
    },
    {
      "time": " 30.Mar.2006 2.25pm",
      "content": "Actually now that I think about it Ohana was a lot bolder than the final Verdana. It was reworked and expanded when it was made for IE. Anything I was saying about Tahoma and Verdana relates to the original work and not the final families you have now.\n\nThe embedded bitmap font was unhinted and removed when Tom finished hinting it.\n\n"
    },
    {
      "time": " 30.Mar.2006 2.29pm",
      "content": "\\> The embedded bitmap font was unhinted  \n\\> and removed when Tom finished hinting it.\n\nYes, I figured as much.  \nBut do you know, or could you please find out, what filesize it was?\n\nhhp\n\n"
    },
    {
      "time": " 31.Mar.2006 1.57am",
      "content": "I had a look at some old data from 09-1994 of Ohana and it was a completely different animal. This was a first draft of one of the faces. I don’t think Matthew would like it to be seen since it’s very geometric and a work in progress. I do think he has shown this in one of his talks about the face. It looks a bit like his ’Walker’ typeface.\n\nThe early bitmaps were designed at 8 pixels high (ascender to descender)for the UI font (regular) and 18, 22 pixels height for the test Display font. These really weren’t ppem but more cell height of the ascender to descender.\n\nLater there were condensed versions which I embedded into TrueType fonts containing only bitmaps and a single ’missing glyph’. The bitmap fonts only contained A-Z, a-z, 0-9, and a couple of test accents like Aring, and Ccedilla plus basic punctuation so we could test it in the system.\n\nThe original font was called MS Sans and compiled into a .fon file with the basic sizes for 96x96 res for testing.\n\nThe first use a font named Tahoma was as a bitmap font based on a Display font previously referred to as ’Ohana’. This font was used for Windows 95’s start-up screen. It was necessary for it to be a bitmap font since during the install process the operating system is not fully installed and only simple formats could be used. Ohana was a nonsense name made from the two senior leads Virginia Howlett and Dave Ohara.\n\nThe first Display test TrueType font; of 299 glyphs (char set ’Win ANSII’; )hinted font with embedded bitmaps for 3 sizes 13, 14, 17 ppem was 77,572 bytes\n\n"
    },
    {
      "time": " 31.Mar.2006 4.18am",
      "content": "Vincent, thanks very much for checking.  \nI’ll see if I can extract anything interesting from your ~78Kb number.\n\n\\> These really weren’t ppem but more cell height of the ascender to descender.\n\nThe only decent way to measure bitmap fonts.\n\nhhp\n\n"
    },
    {
      "time": " 31.Mar.2006 5.07am",
      "content": "“OpenType was to solve more serious problems such as ones in languages.”  \n;-o. Like they actually “solved” that? And, is drawing a kabillion characters actually more serious than not being able to read them at low res.? :-•\n\n"
    },
    {
      "time": " 31.Mar.2006 5.19am",
      "content": "It’s the difference between legibility (where having <cite>anything</cite> is -naturally- better than nothing) and readability (without which you can still read, just not comfortably), with the former always getting more attention because it’s much more obvious. The good news is that you could say this is natural evolution, in that complex scripts acquire the basics first, and then they (and Latin as a consequence) move up to more sophisticated things like optical scaling and good bitmaps. On the other hand, there will always be more money (hence development, at least in a capitalistic framework) in legibility than readability.\n\nhhp\n\n"
    },
    {
      "time": " 11.Apr.2006 2.28pm",
      "content": "Hr: BTW, why such a fine scale? I thought Windows (for one) uses  \nonly 16 shades of gray when rendering gs fonts, which would  \nmean 1/4 pixels (in each dimension) should be enough, no?\n\nTT is overbuilt, typical of a good long-term standard. There also 72 different rounding states possible.\n\nVC: You can’t read between fonts. The code in the font is internal.\n\nLiterally, this is true, but you can however pass info and code from one font to another by including, e.g. a Roman cvt stem value in the CVT of the Bold to make sure they’ll always be different, or e.g. an identical function acting upon a cascade of cvts.\n\nFonts can talk to each other through TT, and as long as all other things in the transformation and rasterization of the fonts is =, all’s well. The Barriers that stop more from happening are in my original crit of OT.\n\n"
    }
  ]
}
